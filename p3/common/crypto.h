#pragma once

#include <openssl/pem.h>

#include "vec.h"

/// size of RSA key
const int RSA_KEYSIZE = 2048;

/// size of AES key
const int AES_KEYSIZE = 32;

/// size of blocks that get encrypted... also size of IV
const int AES_BLOCKSIZE = 16;

/// chunk size for reading/writing from files
const int AES_BUFSIZE = 1024;

/// Load an RSA public key from the given filename
///
/// @param filename The name of the file that has the public key in it
///
/// @returns An RSA context for encrypting with the provided public key, or
///          nullptr on error
RSA *load_pub(const char *filename);

/// Run the AES symmetric encryption/decryption algorithm on a vector of bytes.
/// Note that this will do either encryption or decryption, depending on how the
/// provided CTX has been configured.  After calling, the CTX cannot be used
/// until it is reset.
///
/// @param ctx The pre-configured AES context to use for this operatoin
/// @param msg A vector of bytes to encrypt/decrypt
///
/// @returns A vector with the encrypted or decrypted result, or an empty vector
vec aes_crypt_msg(EVP_CIPHER_CTX *ctx, const vec &msg);

/// Run the AES symmetric encryption/decryption algorithm on a string. Note that
/// this will do either encryption or decryption, depending on how the provided
/// CTX has been configured.  After calling, the CTX cannot be used until it is
/// reset.
///
/// @param ctx The pre-configured AES context to use for this operatoin
/// @param msg A string to encrypt/decrypt
///
/// @returns A vector with the encrypted or decrypted result, or an empty vector
vec aes_crypt_msg(EVP_CIPHER_CTX *ctx, const std::string &msg);

/// Create an AES key.  A key is two parts, the key itself, and the
/// initialization vector.  Each is just random bits.  Our key will just be a
/// stream of random bits, long enough to be split into the actual key and the
/// iv.
///
/// @returns a vector holding the key and iv bits
vec create_aes_key();

/// Create an aes context for doing a single encryption or decryption.  The
/// context must be reset after each full encrypt/decrypt.
///
/// @param key     A vector holding the bits of the key and iv
/// @param encrypt True to encrypt, false to decrypt
///
/// @returns An AES context for doing encryption.  Note that the context can be
///          reset in order to re-use this object for another encryption.
EVP_CIPHER_CTX *create_aes_context(const vec &key, bool encrypt);

/// Reset an existing AES context, so that we can use it for another
/// encryption/decryption
///
/// @param ctx     The AES context to reset
/// @param key     A vector holding the bits of the key and iv.  Should be
///                generated by create_aes_key().
/// @param encrypt True to create an encryption context, false to create a
///                decryption context
///
/// @returns false on error, true if the context is reset and ready to use again
bool reset_aes_context(EVP_CIPHER_CTX *ctx, vec &key, bool encrypt);

/// When an AES context is done being used, call this to reclaim its memory
///
/// @param ctx The context to reclaim
void reclaim_aes_context(EVP_CIPHER_CTX *ctx);

/// If the given basename resolves to basename.pri and basename.pub, then load
/// basename.pri and return it.  If one or the other doesn't exist, then there's
/// an error.  If both don't exist, create them and then load basename.pri.
///
/// @param basename The basename of the .pri and .pub files for RSA
///
/// @returns The RSA context from loading the private file, or nullptr on error
RSA *init_RSA(const std::string &basename);
